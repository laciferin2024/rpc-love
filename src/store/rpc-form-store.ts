import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { devtools, persist } from 'zustand/middleware';
import { Octokit } from 'octokit';
import { getOrCreateFork, createBranch, updateFile, createPullRequest, getFileContent } from '@/lib/github';
import { prepareCsvUpdates } from '@/lib/csv';
import { z } from 'zod';
import { rpcFormSchema } from '@/lib/schemas';
export type CsvRow = Record<string, any>;
export type RpcFormData = z.infer<typeof rpcFormSchema>;
type AuthState = {
  isAuthenticated: boolean;
  accessToken: string | null;
  user: any | null;
};
type SubmissionState = {
  status: 'idle' | 'pending' | 'success' | 'error';
  branchName: string;
  commitMessage: string;
  prTitle: string;
  prBody: string;
  prUrl: string | null;
  error: string | null;
};
type RpcFormState = {
  providers: CsvRow[];
  networkRpcs: CsvRow[];
  isLoading: boolean;
  error: string | null;
  formData: RpcFormData;
  currentStep: number;
  auth: AuthState;
  submission: SubmissionState;
};
type RpcFormActions = {
  fetchCsvData: () => Promise<void>;
  setFormData: (data: Partial<RpcFormData> | ((draft: RpcFormData) => void)) => void;
  nextStep: () => void;
  prevStep: () => void;
  goToStep: (step: number) => void;
  reset: () => void;
  setAuth: (data: { accessToken: string; user: any }) => void;
  logout: () => void;
  prepareSubmission: () => void;
  setSubmissionDetails: (details: Partial<SubmissionState>) => void;
  submitToGitHub: () => Promise<void>;
};
const initialFormData: RpcFormData = {
  providerType: 'existing',
  existingProviderSlug: '',
  newProvider: { name: '', slug: '' },
  network: {
    slug: '',
    plan: '',
    nodeType: '',
    chain: 'mainnet',
    accessPrice: '',
    queryPrice: '',
    availableApis: [],
    actionButtons: [],
    isTrial: false,
    isStarred: false,
  },
};
const initialAuthState: AuthState = { isAuthenticated: false, accessToken: null, user: null };
const initialSubmissionState: SubmissionState = {
  status: 'idle',
  branchName: '',
  commitMessage: '',
  prTitle: '',
  prBody: 'This PR was generated by the RPC Love submission tool.',
  prUrl: null,
  error: null,
};
export const useRpcFormStore = create<RpcFormState & RpcFormActions>()(
  devtools(
    persist(
      immer((set, get) => ({
        providers: [],
        networkRpcs: [],
        isLoading: true,
        error: null,
        formData: initialFormData,
        currentStep: 1,
        auth: initialAuthState,
        submission: initialSubmissionState,
        fetchCsvData: async () => {
          set({ isLoading: true, error: null });
          try {
            const { fetchAndParseCsv } = await import('@/lib/csv');
            const [providersData, networkRpcsData] = await Promise.all([
              fetchAndParseCsv('https://raw.githubusercontent.com/Chain-Love/chain-love/refs/heads/main/providers/rpc.csv'),
              fetchAndParseCsv('https://raw.githubusercontent.com/Chain-Love/chain-love/refs/heads/main/networks/filecoin/rpc.csv'),
            ]);
            set((state) => {
              state.providers = providersData;
              state.networkRpcs = networkRpcsData;
              state.isLoading = false;
            });
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Failed to fetch CSV data';
            set({ error: errorMessage, isLoading: false });
          }
        },
        setFormData: (updater) => set((state) => {
          if (typeof updater === 'function') {
            updater(state.formData as RpcFormData);
          } else {
            state.formData = {
              ...state.formData, ...updater,
              newProvider: { ...state.formData.newProvider, ...updater.newProvider },
              network: { ...state.formData.network, ...updater.network },
            };
          }
        }),
        nextStep: () => set((state) => ({ currentStep: Math.min(state.currentStep + 1, 3) })),
        prevStep: () => set((state) => ({ currentStep: Math.max(state.currentStep - 1, 1) })),
        goToStep: (step) => set({ currentStep: step }),
        reset: () => set((state) => {
          state.formData = initialFormData;
          state.currentStep = 1;
          state.submission = initialSubmissionState;
        }),
        setAuth: (data) => set((state) => {
          state.auth.isAuthenticated = true;
          state.auth.accessToken = data.accessToken;
          state.auth.user = data.user;
        }),
        logout: () => set((state) => { state.auth = initialAuthState; }),
        prepareSubmission: () => set((state) => {
          const slug = state.formData.network.slug;
          const timestamp = Math.floor(Date.now() / 1000);
          const branchName = `cl-rpc-${slug}-${timestamp}`;
          const commitMessage = `feat: add ${slug} to filecoin network`;
          const prTitle = `feat(rpc): Add ${slug} for Filecoin`;
          state.submission.branchName = branchName;
          state.submission.commitMessage = commitMessage;
          state.submission.prTitle = prTitle;
        }),
        setSubmissionDetails: (details) => set((state) => {
          state.submission = { ...state.submission, ...details };
        }),
        submitToGitHub: async () => {
          const { auth, submission, formData, providers, networkRpcs } = get();
          if (!auth.accessToken || !auth.user) {
            set((s) => { s.submission.status = 'error'; s.submission.error = 'Not authenticated.'; });
            return;
          }
          set((s) => { s.submission.status = 'pending'; s.submission.error = null; });
          try {
            const octokit = new Octokit({ auth: auth.accessToken });
            const userLogin = auth.user.login;
            const fork = await getOrCreateFork(octokit);
            await createBranch(octokit, userLogin, fork.name, submission.branchName);
            const { providersCsv, networkRpcsCsv, providerChanges, networkChanges } = prepareCsvUpdates(formData, providers, networkRpcs);
            if (providerChanges) {
              const { sha } = await getFileContent(octokit, userLogin, fork.name, 'providers/rpc.csv', submission.branchName);
              await updateFile(octokit, userLogin, fork.name, 'providers/rpc.csv', providersCsv, submission.commitMessage, submission.branchName, sha);
            }
            if (networkChanges) {
              const { sha } = await getFileContent(octokit, userLogin, fork.name, 'networks/filecoin/rpc.csv', submission.branchName);
              await updateFile(octokit, userLogin, fork.name, 'networks/filecoin/rpc.csv', networkRpcsCsv, submission.commitMessage, submission.branchName, sha);
            }
            const pr = await createPullRequest(octokit, userLogin, fork.name, submission.branchName, 'main', submission.prTitle, submission.prBody);
            set((s) => {
              s.submission.status = 'success';
              s.submission.prUrl = pr.html_url;
            });
          } catch (error: any) {
            console.error("GitHub Submission Error:", error);
            const errorMessage = error.message || 'An unknown error occurred during submission.';
            set((s) => {
              s.submission.status = 'error';
              s.submission.error = errorMessage;
            });
          }
        },
      })),
      {
        name: 'rpc-love-storage',
        partialize: (state) => ({ auth: state.auth, formData: state.formData, currentStep: state.currentStep }),
      }
    )
  )
);